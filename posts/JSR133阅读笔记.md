---
title: JSR133阅读笔记
date: 2017-11-03 10:46:09
tags: [Java,JMM]
---

读了JSR133和Paul神的JSR133FAQ，简单记录下自己的理解。按照FAQ的章节安排。
## 1. 什么是内存模型
在多处理器系统中，每个核都会有一至多级缓存来加速数据的访问（减少内存总线的访问、Cache与Core的距离更小）。但是这带来了一个新的问题，如果多处理器同时修改一块内存地址时会发生什么？在什么情况下这些处理器会看到同一个值？

在处理器层面，内存模型定义了一些必要且足够的条件来限定其它处理器对内存的写操作对当前处理器可见，以及当前处理器的写对其他处理器可见。

一些处理器使用了强内存模型，即任何时刻所有处理器看到的都是一致的内存，写操作立即可见。另外一些处理器采用了弱内存模型，利用内存屏障这一特殊指令来强制缓存失效，从主内存读取值。

尽管强内存模型下更容易编写多处理器下运行正确的代码，但是内存屏障在很多时候还是必要的。比如为了提升运行效率，指令会进行重排序，一些写操作可能前置或后置。在这种情况下，强内存模型的代码无法保证程序的正确性，因为代码执行循序和编写顺序是不一致的。这也就是常说的重排序优化。

对于Java而言，由于在语言层面提供了多线程模型，那么多个线程的共享变量的可见性必须要有一定的规则保证。由于无法枚举可能的代码执行顺序，所以需要通过规则来验证多线程代码是正确的。


## 2. JSR133要解决什么问题？
1. 保留已有的安全保证，比如类型安全，并且加强其他安全保证。例如，变量的值不会出现'out of thin air'问题：一个线程观测的变量值一定对其他线程来说是合理的。
2. 提出简单明确的正确同步的语义。
3. 定义不正确或不完全同步程序以此来减少线程安全问题。
4. 帮助开发者写出正确的多线程程序,正确的与内存交互。
5. 使设计正确的高并发的跨平台的JVM实现成为可能。
6. 初始化安全的保证。当一个对象实例初始化完成后，将产生一个引用对象（指引用不会在初始化时逃逸），对此对象的final字段访问将是线程安全的，不需要额外的同步。
7. 对现有代码影响最小。

## 3. 不正确同步的程序是如何定义的?
1. 一个线程对共享变量读。
2. 另外一个线程对共享变量写。
3. 读写顺序没有同步。

由于没有同步，代码的执行顺序不确定，所以可能产生`write->read`,`read-write`两种可能。这两种情况下读到变量的值是不同的，程序也就不能产生确定的正确输出。这种情况也叫产生了数据争用（data race）。一个产生了数据争用的程序是不正确同步的程序。

## 4. 同步做了什么?
1. 互斥访问。同一时刻只能有一个线程拥有对象实例的管程并执行同步代码块，其他线程无法拥有管程直到之前拥有管程的线程释放管程。
2. 可见性保证。 当一个线程进入同步代码块时，会从内存中刷新需要使用到的变量值，确保变量值为最新，当退出管程时，会刷新变量值到内存中。也就是让属于线程的cache失效(工作内存)。


注意，同步并没有禁止指令重排序，而是遵守happens-before原则，保证重排序后的可见性。




